#if MACINTOSH/* (c)2003 Hotsprings Inc. Licensed under GPL - see LICENSE in HotlineSources diresctory */#include "UTimer.h"#include <Timer.h>#if !TARGET_API_MAC_CARBON	enum {		uppExitToShellProcInfo = kPascalStackBased	};		static pascal void _APExitToShell();	typedef UniversalProcPtr ExitToShellUPP;	static ExitToShellUPP _APSaveExitToShell = nil;	#define CallExitToShellProc(proc)	::CallUniversalProc((UniversalProcPtr) (proc), uppExitToShellProcInfo)	static RoutineDescriptor _APExitToShellRD = BUILD_ROUTINE_DESCRIPTOR(uppExitToShellProcInfo, _APExitToShell);#endifstatic pascal void _APTimerProc(TMTask *inTask);#if TARGET_API_MAC_CARBON	static TimerUPP _APTimerUPP	= ::NewTimerUPP(_APTimerProc);#else	static RoutineDescriptor _APTimerRD = BUILD_ROUTINE_DESCRIPTOR(uppTimerProcInfo, _APTimerProc);	#define _APTimerUPP					(&_APTimerRD)#endifstruct STimer {	TMTask tm;	STimer *next;	TMessageProc proc;	void *context;	Uint32 repeat;	Uint16 wentOff;};#define REF		((STimer *)inRef)void _WakeupApp();static void _APDeinitTimers();static STimer *_APFirstTimer = nil;/* -------------------------------------------------------------------------- */void UTimer::Init(){	// init only once	static Uint8 isInitted = false;	if (isInitted) return;	isInitted = true;		UProgramCleanup::InstallAppl(_APDeinitTimers);			// Carbon does not support Path Manager#if !TARGET_API_MAC_CARBON	if (_APSaveExitToShell == nil)	{		// patch ExitToShell		_APSaveExitToShell = (ExitToShellUPP)::NGetTrapAddress(_ExitToShell, (_ExitToShell & 0x0800) ? ToolTrap : OSTrap);		::NSetTrapAddress((UniversalProcPtr)&_APExitToShellRD, _ExitToShell, (_ExitToShell & 0x0800) ? ToolTrap : OSTrap);	}#endif}TTimer UTimer::New(TMessageProc inProc, void *inContext){	STimer *timer = (STimer *)UMemory::NewClear(sizeof(STimer));		timer->tm.tmAddr = _APTimerUPP;	timer->proc = inProc;	timer->context = inContext;	timer->next = _APFirstTimer;	_APFirstTimer = timer;	return (TTimer)timer;}TTimer UTimer::StartNew(TMessageProc inProc, void *inContext, Uint32 inMillisecs, Uint32 inIsRepeating){	STimer *timer = (STimer *)UMemory::NewClear(sizeof(STimer));		timer->tm.tmAddr = _APTimerUPP;	timer->proc = inProc;	timer->context = inContext;	timer->next = _APFirstTimer;	_APFirstTimer = timer;		if (inMillisecs > max_Int32) inMillisecs = max_Int32;	timer->repeat = inIsRepeating ? inMillisecs : 0;	#if TARGET_API_MAC_CARBON	::InstallXTimeTask((QElemPtr)timer);#else	::InsXTime((QElemPtr)timer);#endif	::PrimeTime((QElemPtr)timer, inMillisecs);	return (TTimer)timer;}void UTimer::Dispose(TTimer inRef){	if (inRef)	{		// remove from mac time mgr queue		::RmvTime((QElemPtr)inRef);				// remove from our queue		STimer *tm = _APFirstTimer;		STimer *ptm = nil;		while (tm)		{			if (tm == REF)			{				if (ptm)					ptm->next = tm->next;				else					_APFirstTimer = tm->next;				break;			}			ptm = tm;			tm = tm->next;		}				// kill any messages generated by this timer		UApplication::FlushMessages(REF->proc, REF->context, inRef);				// release memory		UMemory::Dispose((TPtr)inRef);	}}void UTimer::Start(TTimer inRef, Uint32 inMillisecs, Uint32 inIsRepeating){	Require(inRef);		Stop(inRef);	if (inMillisecs > max_Int32) inMillisecs = max_Int32;	REF->repeat = inIsRepeating ? inMillisecs : 0;	#if TARGET_API_MAC_CARBON	::InstallXTimeTask((QElemPtr)inRef);#else	::InsXTime((QElemPtr)inRef);#endif	::PrimeTime((QElemPtr)inRef, inMillisecs);}bool UTimer::WasStarted(TTimer inRef){	if (REF->tm.qLink || REF->tm.qType || REF->tm.tmCount || REF->tm.tmWakeUp)		return true;			return false;}void UTimer::Stop(TTimer inRef){	if (inRef)	{		::RmvTime((QElemPtr)inRef);		REF->wentOff = false;		REF->tm.qLink = nil;		REF->tm.qType = 0;		REF->tm.tmCount = 0;		REF->tm.tmWakeUp = 0;		REF->tm.tmReserved = 0;	}}// simulate the timer going off (does not affect time remaining etc)void UTimer::Simulate(TTimer inRef){	if (inRef) UApplication::ReplaceMessage(msg_Timer, nil, 0, priority_Timer, REF->proc, REF->context, inRef);}/* -------------------------------------------------------------------------- */#pragma mark -static pascal void _APTimerProc(TMTask *inTask){		((STimer *)inTask)->wentOff = true;		_WakeupApp();}void _APProcessTimers(){	STimer *tm = (STimer *)_APFirstTimer;	while (tm)	{		if (tm->wentOff)		{			UTimer::Stop((TTimer)tm);						if (tm->repeat)			{			#if TARGET_API_MAC_CARBON				::InstallXTimeTask((QElemPtr)tm);			#else				::InsXTime((QElemPtr)tm);			#endif							::PrimeTime((QElemPtr)tm, tm->repeat);			}						UApplication::ReplaceMessage(msg_Timer, nil, 0, priority_Timer, tm->proc, tm->context, tm);		}		tm = tm->next;	}}static void _APDeinitTimers(){	STimer *tm = _APFirstTimer;		while (tm)	{		::RmvTime((QElemPtr)tm);		tm = tm->next;	}}#if !TARGET_API_MAC_CARBON// This patch removes all timer tasks when the application is terminated.// If this isn't done, the computer is likely to crash pretty soon.static pascal void _APExitToShell(){		_APDeinitTimers();		CallExitToShellProc(_APSaveExitToShell);}#endif#endif /* MACINTOSH */