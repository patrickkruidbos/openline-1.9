/***** news database struct *****/// note that each article can have up to one of each flavor	// ie, one article cannot hold two text/plain or image/jpeg or whatever// use 32bit offsets for future expanadbility?// ie, if the db is full, move the first 8k of news blocks to the end of the file and add to the offset table?// but then need to ensure all future refs to article 1 are valid...	// refs include links (PREV/NEXT), and children to parents// alternatively, could place the table at the end//first 512 bytes always reserved for the following:// even if the block size is not 512 bytes, the first 512 bytes are a header.// byte 512 is the start of block 1 ie. offset 1// size = 4 + 4 + 4 + 5 * 4 + 4 + 2 + 2 + 2 + 2 + 4 + 4 * 4 + 1 + 31 * 1 + 1 + 255 * 1  (+ rsvd)// all offsets are blocks into the database.  this header is block 0// the alloc table should *always* be at offset 1// the alloc table *must* be contiguousstruct{	Uint32 type;	// = HLNZ	Uint32 vers;	// 1	Uint32 id;	Uint32 blockSize;		Uint32 rsvd[4];		Uint32 articleCount;	Uint16 firstArticleOffset;	Uint16 lastArticleOffset;		Uint32 nextArticleID;	Uint32 allocTableCRC;		// ensure it's not corrupt	Uint16 allocTableOffset;	Uint16 allocTableSize;		// in bytes			Uint32 rsvd[3];	Uint8 nameSize;	Uint8 name[31];		Uint8 descSize;	Uint8 description[255];	Uint8 rsvd[160];};// allocTablebit table on if the corresponding block is allocated, off if not// actual data//  "application/x-hlnewsitem"//  "text/plain", "image/jpeg", "image/gif", etc.struct SNewsBlock{	Uint16 nextFlav;	// offset of next flavor in this item (0 if none exists)	Uint16 size;		// if this item spans over to the next block, it's the total size 	Pstring type;		// mime type of data	Uint8 padding[]		// from 0 to 3 depending on what's necessary for data to fit on a 4-byte boundary	Uint8 data[size];};// in SNewsBlock, data is:	// application/x-hlnewsitem	struct SNewsIndex	{		Uint32 id;		Uint16 prevArticleOffset;	// offset of the prev news item in this level - 0 if i'm first		Uint16 nextArticleOffset;	// offset of the next news item in this level - 0 if i'm last		Uint16 parentOffset;		Uint16 firstChildOffset;						SDateTimeStamp date;		// 8 bytes of date data when this item was modified		Uint32 flags;				// priorities and such		Uint8 title[32];			// pstring of the name of the folder, or name of the item		Uint8 poster[32];			// pstring of the sender of this post	};	// "text/plain", "image/jpeg", "image/gif", etc...	Uint8 data[];// to do:/*In the future version (prolly release vers) have a table with offsets and IDsEssentially, the following will happenthere is a table 64 * 2 = 128 bytes of 6-bit ids to offsets into a tableto look up an id, distill the 4-byte id to 6 bits.- read the two-byte offset + two-byte length into the table at location 4 times that 6-bitsthis value read is the offset into the file of the id-offset table of ids with that distillation valueread that block at offset of length sizedo a binary search for the id we're looking for.Once we find the id, it will have two-bytes slapped onto	these are the offset into the file of the article of this ID	if none is found, there is no article of this ID*/